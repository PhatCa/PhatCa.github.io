---
layout: essay
type: essay
title: "Design Pattern"
# All dates must be YYYY-MM-DD format!
date: 2023-04-25
published: true
labels:
  - Coding
  - Framework
  - Design Pattern

---

<img width="300px" class="rounded float-start pe-4" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQ2wuaNbKisxwvTwSMuugQqRl6WmVxc1YHR2oxYNpeQSg&s">


## My Experience With New Design Patterns

Design patterns are like secret codes that help us talk to each other in the programming world. I remember when I started using framework like Pythonâ€™s Django, figuring out how its files were organized and noticing the patterns made it way easier for me to understand. When I tried other frameworks later on like Meteor js, I could still see those same patterns from Django, and it made learning them quicker. So, what exactly are design patterns, and how did they make it easier for me to switch from using Python's Django framework to working with Meteor.js and React in JavaScript?


## What Design Pattern really is?

Design patterns act as blueprints for programmers, providing tried-and-tested solutions to common problems. As I explored the intricacies of various frameworks, I began to see recurring patterns emerge, forming a common thread across different coding environments. These patterns weren't just about syntax or structure; they were about understanding the underlying principles that govern software design. Whether it was Django's MVC architecture or Meteor.js's reactive paradigm, grasping these patterns enabled me to adapt and thrive in diverse coding landscapes. So, while design patterns may seem like abstract concepts at first, they are the building blocks that empower programmers to navigate the ever-changing seas of technology.

## What did I use in my project?
In my Meteor.js React project, I primarily follow two key design patterns: Component Composition and Container-Presentational Component Separation. I leverage React's emphasis on composition over inheritance, which allows me to build complex user interfaces by combining smaller, reusable components. This approach enhances modularity and simplifies code maintenance by breaking down UI elements into manageable pieces. Additionally, I adhere to the container-presentational component pattern, where container components handle data fetching and state management logic, while presentational components focus solely on rendering UI elements based on the props they receive. By organizing my components in this manner, I promote code reusability, maintainability, and a clear separation of concerns within my Meteor.js React project.
